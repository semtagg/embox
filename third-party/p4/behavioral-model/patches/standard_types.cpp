/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "standard_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

#include <sstream>
namespace patch5
{
    template < typename T > std::string to_string( const T& n )
    {
        std::ostringstream stm ;
        stm << n ;
        return stm.str() ;
    }
}

namespace bm_runtime { namespace standard {

int _kBmMatchParamTypeValues[] = {
  BmMatchParamType::EXACT,
  BmMatchParamType::LPM,
  BmMatchParamType::TERNARY,
  BmMatchParamType::VALID,
  BmMatchParamType::RANGE
};
const char* _kBmMatchParamTypeNames[] = {
  "EXACT",
  "LPM",
  "TERNARY",
  "VALID",
  "RANGE"
};
const std::map<int, const char*> _BmMatchParamType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kBmMatchParamTypeValues, _kBmMatchParamTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const BmMatchParamType::type& val) {
  std::map<int, const char*>::const_iterator it = _BmMatchParamType_VALUES_TO_NAMES.find(val);
  if (it != _BmMatchParamType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const BmMatchParamType::type& val) {
  std::map<int, const char*>::const_iterator it = _BmMatchParamType_VALUES_TO_NAMES.find(val);
  if (it != _BmMatchParamType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return patch5::to_string(static_cast<int>(val));
  }
}

int _kTableOperationErrorCodeValues[] = {
  TableOperationErrorCode::TABLE_FULL,
  TableOperationErrorCode::INVALID_HANDLE,
  TableOperationErrorCode::EXPIRED_HANDLE,
  TableOperationErrorCode::COUNTERS_DISABLED,
  TableOperationErrorCode::METERS_DISABLED,
  TableOperationErrorCode::AGEING_DISABLED,
  TableOperationErrorCode::INVALID_TABLE_NAME,
  TableOperationErrorCode::INVALID_ACTION_NAME,
  TableOperationErrorCode::WRONG_TABLE_TYPE,
  TableOperationErrorCode::INVALID_MBR_HANDLE,
  TableOperationErrorCode::MBR_STILL_USED,
  TableOperationErrorCode::MBR_ALREADY_IN_GRP,
  TableOperationErrorCode::MBR_NOT_IN_GRP,
  TableOperationErrorCode::INVALID_GRP_HANDLE,
  TableOperationErrorCode::GRP_STILL_USED,
  TableOperationErrorCode::EMPTY_GRP,
  TableOperationErrorCode::DUPLICATE_ENTRY,
  TableOperationErrorCode::BAD_MATCH_KEY,
  TableOperationErrorCode::INVALID_METER_OPERATION,
  TableOperationErrorCode::DEFAULT_ACTION_IS_CONST,
  TableOperationErrorCode::DEFAULT_ENTRY_IS_CONST,
  TableOperationErrorCode::NO_DEFAULT_ENTRY,
  TableOperationErrorCode::INVALID_ACTION_PROFILE_NAME,
  TableOperationErrorCode::NO_ACTION_PROFILE_SELECTION,
  TableOperationErrorCode::IMMUTABLE_TABLE_ENTRIES,
  TableOperationErrorCode::BAD_ACTION_DATA,
  TableOperationErrorCode::ERROR
};
const char* _kTableOperationErrorCodeNames[] = {
  "TABLE_FULL",
  "INVALID_HANDLE",
  "EXPIRED_HANDLE",
  "COUNTERS_DISABLED",
  "METERS_DISABLED",
  "AGEING_DISABLED",
  "INVALID_TABLE_NAME",
  "INVALID_ACTION_NAME",
  "WRONG_TABLE_TYPE",
  "INVALID_MBR_HANDLE",
  "MBR_STILL_USED",
  "MBR_ALREADY_IN_GRP",
  "MBR_NOT_IN_GRP",
  "INVALID_GRP_HANDLE",
  "GRP_STILL_USED",
  "EMPTY_GRP",
  "DUPLICATE_ENTRY",
  "BAD_MATCH_KEY",
  "INVALID_METER_OPERATION",
  "DEFAULT_ACTION_IS_CONST",
  "DEFAULT_ENTRY_IS_CONST",
  "NO_DEFAULT_ENTRY",
  "INVALID_ACTION_PROFILE_NAME",
  "NO_ACTION_PROFILE_SELECTION",
  "IMMUTABLE_TABLE_ENTRIES",
  "BAD_ACTION_DATA",
  "ERROR"
};
const std::map<int, const char*> _TableOperationErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(27, _kTableOperationErrorCodeValues, _kTableOperationErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TableOperationErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _TableOperationErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _TableOperationErrorCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TableOperationErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _TableOperationErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _TableOperationErrorCode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return patch5::to_string(static_cast<int>(val));
  }
}

int _kCounterOperationErrorCodeValues[] = {
  CounterOperationErrorCode::INVALID_COUNTER_NAME,
  CounterOperationErrorCode::INVALID_INDEX,
  CounterOperationErrorCode::ERROR
};
const char* _kCounterOperationErrorCodeNames[] = {
  "INVALID_COUNTER_NAME",
  "INVALID_INDEX",
  "ERROR"
};
const std::map<int, const char*> _CounterOperationErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kCounterOperationErrorCodeValues, _kCounterOperationErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const CounterOperationErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _CounterOperationErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _CounterOperationErrorCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CounterOperationErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _CounterOperationErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _CounterOperationErrorCode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return patch5::to_string(static_cast<int>(val));
  }
}

int _kSwapOperationErrorCodeValues[] = {
  SwapOperationErrorCode::CONFIG_SWAP_DISABLED,
  SwapOperationErrorCode::ONGOING_SWAP,
  SwapOperationErrorCode::NO_ONGOING_SWAP
};
const char* _kSwapOperationErrorCodeNames[] = {
  "CONFIG_SWAP_DISABLED",
  "ONGOING_SWAP",
  "NO_ONGOING_SWAP"
};
const std::map<int, const char*> _SwapOperationErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kSwapOperationErrorCodeValues, _kSwapOperationErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const SwapOperationErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _SwapOperationErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _SwapOperationErrorCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SwapOperationErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _SwapOperationErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _SwapOperationErrorCode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return patch5::to_string(static_cast<int>(val));
  }
}

int _kMeterOperationErrorCodeValues[] = {
  MeterOperationErrorCode::INVALID_METER_NAME,
  MeterOperationErrorCode::INVALID_INDEX,
  MeterOperationErrorCode::BAD_RATES_LIST,
  MeterOperationErrorCode::INVALID_INFO_RATE_VALUE,
  MeterOperationErrorCode::INVALID_BURST_SIZE_VALUE,
  MeterOperationErrorCode::ERROR
};
const char* _kMeterOperationErrorCodeNames[] = {
  "INVALID_METER_NAME",
  "INVALID_INDEX",
  "BAD_RATES_LIST",
  "INVALID_INFO_RATE_VALUE",
  "INVALID_BURST_SIZE_VALUE",
  "ERROR"
};
const std::map<int, const char*> _MeterOperationErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kMeterOperationErrorCodeValues, _kMeterOperationErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MeterOperationErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _MeterOperationErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _MeterOperationErrorCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const MeterOperationErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _MeterOperationErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _MeterOperationErrorCode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return patch5::to_string(static_cast<int>(val));
  }
}

int _kRegisterOperationErrorCodeValues[] = {
  RegisterOperationErrorCode::INVALID_REGISTER_NAME,
  RegisterOperationErrorCode::INVALID_INDEX,
  RegisterOperationErrorCode::ERROR
};
const char* _kRegisterOperationErrorCodeNames[] = {
  "INVALID_REGISTER_NAME",
  "INVALID_INDEX",
  "ERROR"
};
const std::map<int, const char*> _RegisterOperationErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kRegisterOperationErrorCodeValues, _kRegisterOperationErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const RegisterOperationErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _RegisterOperationErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _RegisterOperationErrorCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const RegisterOperationErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _RegisterOperationErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _RegisterOperationErrorCode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return patch5::to_string(static_cast<int>(val));
  }
}

int _kParseVSetOperationErrorCodeValues[] = {
  ParseVSetOperationErrorCode::INVALID_PARSE_VSET_NAME,
  ParseVSetOperationErrorCode::ERROR
};
const char* _kParseVSetOperationErrorCodeNames[] = {
  "INVALID_PARSE_VSET_NAME",
  "ERROR"
};
const std::map<int, const char*> _ParseVSetOperationErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kParseVSetOperationErrorCodeValues, _kParseVSetOperationErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ParseVSetOperationErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _ParseVSetOperationErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _ParseVSetOperationErrorCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ParseVSetOperationErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _ParseVSetOperationErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _ParseVSetOperationErrorCode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return patch5::to_string(static_cast<int>(val));
  }
}

int _kLearnOperationErrorCodeValues[] = {
  LearnOperationErrorCode::INVALID_LIST_ID,
  LearnOperationErrorCode::INVALID_LIST_NAME,
  LearnOperationErrorCode::ERROR
};
const char* _kLearnOperationErrorCodeNames[] = {
  "INVALID_LIST_ID",
  "INVALID_LIST_NAME",
  "ERROR"
};
const std::map<int, const char*> _LearnOperationErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kLearnOperationErrorCodeValues, _kLearnOperationErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const LearnOperationErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _LearnOperationErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _LearnOperationErrorCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LearnOperationErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _LearnOperationErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _LearnOperationErrorCode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return patch5::to_string(static_cast<int>(val));
  }
}

int _kDevMgrErrorCodeValues[] = {
  DevMgrErrorCode::ERROR
};
const char* _kDevMgrErrorCodeNames[] = {
  "ERROR"
};
const std::map<int, const char*> _DevMgrErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kDevMgrErrorCodeValues, _kDevMgrErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const DevMgrErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _DevMgrErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _DevMgrErrorCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const DevMgrErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _DevMgrErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _DevMgrErrorCode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return patch5::to_string(static_cast<int>(val));
  }
}

int _kCrcErrorCodeValues[] = {
  CrcErrorCode::INVALID_CALCULATION_NAME,
  CrcErrorCode::WRONG_TYPE_CALCULATION,
  CrcErrorCode::INVALID_CONFIG
};
const char* _kCrcErrorCodeNames[] = {
  "INVALID_CALCULATION_NAME",
  "WRONG_TYPE_CALCULATION",
  "INVALID_CONFIG"
};
const std::map<int, const char*> _CrcErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kCrcErrorCodeValues, _kCrcErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const CrcErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _CrcErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _CrcErrorCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CrcErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _CrcErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _CrcErrorCode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return patch5::to_string(static_cast<int>(val));
  }
}

int _kBmActionEntryTypeValues[] = {
  BmActionEntryType::NONE,
  BmActionEntryType::ACTION_DATA,
  BmActionEntryType::MBR_HANDLE,
  BmActionEntryType::GRP_HANDLE
};
const char* _kBmActionEntryTypeNames[] = {
  "NONE",
  "ACTION_DATA",
  "MBR_HANDLE",
  "GRP_HANDLE"
};
const std::map<int, const char*> _BmActionEntryType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kBmActionEntryTypeValues, _kBmActionEntryTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const BmActionEntryType::type& val) {
  std::map<int, const char*>::const_iterator it = _BmActionEntryType_VALUES_TO_NAMES.find(val);
  if (it != _BmActionEntryType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const BmActionEntryType::type& val) {
  std::map<int, const char*>::const_iterator it = _BmActionEntryType_VALUES_TO_NAMES.find(val);
  if (it != _BmActionEntryType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return patch5::to_string(static_cast<int>(val));
  }
}

int _kBmResourceTypeValues[] = {
  BmResourceType::MATCH_TABLE,
  BmResourceType::ACTION_PROFILE,
  BmResourceType::COUNTER,
  BmResourceType::METER,
  BmResourceType::REGISTER,
  BmResourceType::LEARNING_LIST
};
const char* _kBmResourceTypeNames[] = {
  "MATCH_TABLE",
  "ACTION_PROFILE",
  "COUNTER",
  "METER",
  "REGISTER",
  "LEARNING_LIST"
};
const std::map<int, const char*> _BmResourceType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kBmResourceTypeValues, _kBmResourceTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const BmResourceType::type& val) {
  std::map<int, const char*>::const_iterator it = _BmResourceType_VALUES_TO_NAMES.find(val);
  if (it != _BmResourceType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const BmResourceType::type& val) {
  std::map<int, const char*>::const_iterator it = _BmResourceType_VALUES_TO_NAMES.find(val);
  if (it != _BmResourceType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return patch5::to_string(static_cast<int>(val));
  }
}

int _kIdLookupErrorCodeValues[] = {
  IdLookupErrorCode::INVALID_RESOURCE_TYPE,
  IdLookupErrorCode::INVALID_RESOURCE_NAME
};
const char* _kIdLookupErrorCodeNames[] = {
  "INVALID_RESOURCE_TYPE",
  "INVALID_RESOURCE_NAME"
};
const std::map<int, const char*> _IdLookupErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kIdLookupErrorCodeValues, _kIdLookupErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const IdLookupErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _IdLookupErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _IdLookupErrorCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const IdLookupErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _IdLookupErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _IdLookupErrorCode_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return patch5::to_string(static_cast<int>(val));
  }
}


BmMatchParamExact::~BmMatchParamExact() noexcept {
}


void BmMatchParamExact::__set_key(const std::string& val) {
  this->key = val;
}
std::ostream& operator<<(std::ostream& out, const BmMatchParamExact& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BmMatchParamExact::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BmMatchParamExact::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BmMatchParamExact");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BmMatchParamExact &a, BmMatchParamExact &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.__isset, b.__isset);
}

BmMatchParamExact::BmMatchParamExact(const BmMatchParamExact& other0) {
  key = other0.key;
  __isset = other0.__isset;
}
BmMatchParamExact& BmMatchParamExact::operator=(const BmMatchParamExact& other1) {
  key = other1.key;
  __isset = other1.__isset;
  return *this;
}
void BmMatchParamExact::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BmMatchParamExact(";
  out << "key=" << to_string(key);
  out << ")";
}


BmMatchParamLPM::~BmMatchParamLPM() noexcept {
}


void BmMatchParamLPM::__set_key(const std::string& val) {
  this->key = val;
}

void BmMatchParamLPM::__set_prefix_length(const int32_t val) {
  this->prefix_length = val;
}
std::ostream& operator<<(std::ostream& out, const BmMatchParamLPM& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BmMatchParamLPM::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->prefix_length);
          this->__isset.prefix_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BmMatchParamLPM::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BmMatchParamLPM");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prefix_length", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->prefix_length);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BmMatchParamLPM &a, BmMatchParamLPM &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.prefix_length, b.prefix_length);
  swap(a.__isset, b.__isset);
}

BmMatchParamLPM::BmMatchParamLPM(const BmMatchParamLPM& other2) {
  key = other2.key;
  prefix_length = other2.prefix_length;
  __isset = other2.__isset;
}
BmMatchParamLPM& BmMatchParamLPM::operator=(const BmMatchParamLPM& other3) {
  key = other3.key;
  prefix_length = other3.prefix_length;
  __isset = other3.__isset;
  return *this;
}
void BmMatchParamLPM::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BmMatchParamLPM(";
  out << "key=" << to_string(key);
  out << ", " << "prefix_length=" << to_string(prefix_length);
  out << ")";
}


BmMatchParamTernary::~BmMatchParamTernary() noexcept {
}


void BmMatchParamTernary::__set_key(const std::string& val) {
  this->key = val;
}

void BmMatchParamTernary::__set_mask(const std::string& val) {
  this->mask = val;
}
std::ostream& operator<<(std::ostream& out, const BmMatchParamTernary& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BmMatchParamTernary::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->mask);
          this->__isset.mask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BmMatchParamTernary::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BmMatchParamTernary");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mask", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->mask);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BmMatchParamTernary &a, BmMatchParamTernary &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.mask, b.mask);
  swap(a.__isset, b.__isset);
}

BmMatchParamTernary::BmMatchParamTernary(const BmMatchParamTernary& other4) {
  key = other4.key;
  mask = other4.mask;
  __isset = other4.__isset;
}
BmMatchParamTernary& BmMatchParamTernary::operator=(const BmMatchParamTernary& other5) {
  key = other5.key;
  mask = other5.mask;
  __isset = other5.__isset;
  return *this;
}
void BmMatchParamTernary::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BmMatchParamTernary(";
  out << "key=" << to_string(key);
  out << ", " << "mask=" << to_string(mask);
  out << ")";
}


BmMatchParamValid::~BmMatchParamValid() noexcept {
}


void BmMatchParamValid::__set_key(const bool val) {
  this->key = val;
}
std::ostream& operator<<(std::ostream& out, const BmMatchParamValid& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BmMatchParamValid::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BmMatchParamValid::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BmMatchParamValid");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BmMatchParamValid &a, BmMatchParamValid &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.__isset, b.__isset);
}

BmMatchParamValid::BmMatchParamValid(const BmMatchParamValid& other6) {
  key = other6.key;
  __isset = other6.__isset;
}
BmMatchParamValid& BmMatchParamValid::operator=(const BmMatchParamValid& other7) {
  key = other7.key;
  __isset = other7.__isset;
  return *this;
}
void BmMatchParamValid::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BmMatchParamValid(";
  out << "key=" << to_string(key);
  out << ")";
}


BmMatchParamRange::~BmMatchParamRange() noexcept {
}


void BmMatchParamRange::__set_start(const std::string& val) {
  this->start = val;
}

void BmMatchParamRange::__set_end_(const std::string& val) {
  this->end_ = val;
}
std::ostream& operator<<(std::ostream& out, const BmMatchParamRange& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BmMatchParamRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->end_);
          this->__isset.end_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BmMatchParamRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BmMatchParamRange");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->end_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BmMatchParamRange &a, BmMatchParamRange &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.end_, b.end_);
  swap(a.__isset, b.__isset);
}

BmMatchParamRange::BmMatchParamRange(const BmMatchParamRange& other8) {
  start = other8.start;
  end_ = other8.end_;
  __isset = other8.__isset;
}
BmMatchParamRange& BmMatchParamRange::operator=(const BmMatchParamRange& other9) {
  start = other9.start;
  end_ = other9.end_;
  __isset = other9.__isset;
  return *this;
}
void BmMatchParamRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BmMatchParamRange(";
  out << "start=" << to_string(start);
  out << ", " << "end_=" << to_string(end_);
  out << ")";
}


BmMatchParam::~BmMatchParam() noexcept {
}


void BmMatchParam::__set_type(const BmMatchParamType::type val) {
  this->type = val;
}

void BmMatchParam::__set_exact(const BmMatchParamExact& val) {
  this->exact = val;
__isset.exact = true;
}

void BmMatchParam::__set_lpm(const BmMatchParamLPM& val) {
  this->lpm = val;
__isset.lpm = true;
}

void BmMatchParam::__set_ternary(const BmMatchParamTernary& val) {
  this->ternary = val;
__isset.ternary = true;
}

void BmMatchParam::__set_valid(const BmMatchParamValid& val) {
  this->valid = val;
__isset.valid = true;
}

void BmMatchParam::__set_range(const BmMatchParamRange& val) {
  this->range = val;
__isset.range = true;
}
std::ostream& operator<<(std::ostream& out, const BmMatchParam& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BmMatchParam::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->type = (BmMatchParamType::type)ecast10;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->exact.read(iprot);
          this->__isset.exact = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lpm.read(iprot);
          this->__isset.lpm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ternary.read(iprot);
          this->__isset.ternary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->valid.read(iprot);
          this->__isset.valid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->range.read(iprot);
          this->__isset.range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BmMatchParam::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BmMatchParam");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.exact) {
    xfer += oprot->writeFieldBegin("exact", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->exact.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lpm) {
    xfer += oprot->writeFieldBegin("lpm", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->lpm.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ternary) {
    xfer += oprot->writeFieldBegin("ternary", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->ternary.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.valid) {
    xfer += oprot->writeFieldBegin("valid", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->valid.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.range) {
    xfer += oprot->writeFieldBegin("range", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->range.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BmMatchParam &a, BmMatchParam &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.exact, b.exact);
  swap(a.lpm, b.lpm);
  swap(a.ternary, b.ternary);
  swap(a.valid, b.valid);
  swap(a.range, b.range);
  swap(a.__isset, b.__isset);
}

BmMatchParam::BmMatchParam(const BmMatchParam& other11) {
  type = other11.type;
  exact = other11.exact;
  lpm = other11.lpm;
  ternary = other11.ternary;
  valid = other11.valid;
  range = other11.range;
  __isset = other11.__isset;
}
BmMatchParam& BmMatchParam::operator=(const BmMatchParam& other12) {
  type = other12.type;
  exact = other12.exact;
  lpm = other12.lpm;
  ternary = other12.ternary;
  valid = other12.valid;
  range = other12.range;
  __isset = other12.__isset;
  return *this;
}
void BmMatchParam::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BmMatchParam(";
  out << "type=" << to_string(type);
  out << ", " << "exact="; (__isset.exact ? (out << to_string(exact)) : (out << "<null>"));
  out << ", " << "lpm="; (__isset.lpm ? (out << to_string(lpm)) : (out << "<null>"));
  out << ", " << "ternary="; (__isset.ternary ? (out << to_string(ternary)) : (out << "<null>"));
  out << ", " << "valid="; (__isset.valid ? (out << to_string(valid)) : (out << "<null>"));
  out << ", " << "range="; (__isset.range ? (out << to_string(range)) : (out << "<null>"));
  out << ")";
}


BmAddEntryOptions::~BmAddEntryOptions() noexcept {
}


void BmAddEntryOptions::__set_priority(const int32_t val) {
  this->priority = val;
__isset.priority = true;
}
std::ostream& operator<<(std::ostream& out, const BmAddEntryOptions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BmAddEntryOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->priority);
          this->__isset.priority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BmAddEntryOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BmAddEntryOptions");

  if (this->__isset.priority) {
    xfer += oprot->writeFieldBegin("priority", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->priority);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BmAddEntryOptions &a, BmAddEntryOptions &b) {
  using ::std::swap;
  swap(a.priority, b.priority);
  swap(a.__isset, b.__isset);
}

BmAddEntryOptions::BmAddEntryOptions(const BmAddEntryOptions& other13) {
  priority = other13.priority;
  __isset = other13.__isset;
}
BmAddEntryOptions& BmAddEntryOptions::operator=(const BmAddEntryOptions& other14) {
  priority = other14.priority;
  __isset = other14.__isset;
  return *this;
}
void BmAddEntryOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BmAddEntryOptions(";
  out << "priority="; (__isset.priority ? (out << to_string(priority)) : (out << "<null>"));
  out << ")";
}


BmCounterValue::~BmCounterValue() noexcept {
}


void BmCounterValue::__set_bytes(const int64_t val) {
  this->bytes = val;
}

void BmCounterValue::__set_packets(const int64_t val) {
  this->packets = val;
}
std::ostream& operator<<(std::ostream& out, const BmCounterValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BmCounterValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bytes);
          this->__isset.bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->packets);
          this->__isset.packets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BmCounterValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BmCounterValue");

  xfer += oprot->writeFieldBegin("bytes", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bytes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("packets", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->packets);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BmCounterValue &a, BmCounterValue &b) {
  using ::std::swap;
  swap(a.bytes, b.bytes);
  swap(a.packets, b.packets);
  swap(a.__isset, b.__isset);
}

BmCounterValue::BmCounterValue(const BmCounterValue& other15) {
  bytes = other15.bytes;
  packets = other15.packets;
  __isset = other15.__isset;
}
BmCounterValue& BmCounterValue::operator=(const BmCounterValue& other16) {
  bytes = other16.bytes;
  packets = other16.packets;
  __isset = other16.__isset;
  return *this;
}
void BmCounterValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BmCounterValue(";
  out << "bytes=" << to_string(bytes);
  out << ", " << "packets=" << to_string(packets);
  out << ")";
}


BmMeterRateConfig::~BmMeterRateConfig() noexcept {
}


void BmMeterRateConfig::__set_units_per_micros(const double val) {
  this->units_per_micros = val;
}

void BmMeterRateConfig::__set_burst_size(const int32_t val) {
  this->burst_size = val;
}
std::ostream& operator<<(std::ostream& out, const BmMeterRateConfig& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BmMeterRateConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->units_per_micros);
          this->__isset.units_per_micros = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->burst_size);
          this->__isset.burst_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BmMeterRateConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BmMeterRateConfig");

  xfer += oprot->writeFieldBegin("units_per_micros", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->units_per_micros);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("burst_size", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->burst_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BmMeterRateConfig &a, BmMeterRateConfig &b) {
  using ::std::swap;
  swap(a.units_per_micros, b.units_per_micros);
  swap(a.burst_size, b.burst_size);
  swap(a.__isset, b.__isset);
}

BmMeterRateConfig::BmMeterRateConfig(const BmMeterRateConfig& other17) {
  units_per_micros = other17.units_per_micros;
  burst_size = other17.burst_size;
  __isset = other17.__isset;
}
BmMeterRateConfig& BmMeterRateConfig::operator=(const BmMeterRateConfig& other18) {
  units_per_micros = other18.units_per_micros;
  burst_size = other18.burst_size;
  __isset = other18.__isset;
  return *this;
}
void BmMeterRateConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BmMeterRateConfig(";
  out << "units_per_micros=" << to_string(units_per_micros);
  out << ", " << "burst_size=" << to_string(burst_size);
  out << ")";
}


InvalidTableOperation::~InvalidTableOperation() noexcept {
}


void InvalidTableOperation::__set_code(const TableOperationErrorCode::type val) {
  this->code = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidTableOperation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidTableOperation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->code = (TableOperationErrorCode::type)ecast19;
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidTableOperation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidTableOperation");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidTableOperation &a, InvalidTableOperation &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.__isset, b.__isset);
}

InvalidTableOperation::InvalidTableOperation(const InvalidTableOperation& other20) : TException() {
  code = other20.code;
  __isset = other20.__isset;
}
InvalidTableOperation& InvalidTableOperation::operator=(const InvalidTableOperation& other21) {
  code = other21.code;
  __isset = other21.__isset;
  return *this;
}
void InvalidTableOperation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidTableOperation(";
  out << "code=" << to_string(code);
  out << ")";
}

const char* InvalidTableOperation::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidTableOperation";
  }
}


InvalidCounterOperation::~InvalidCounterOperation() noexcept {
}


void InvalidCounterOperation::__set_code(const CounterOperationErrorCode::type val) {
  this->code = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidCounterOperation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidCounterOperation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->code = (CounterOperationErrorCode::type)ecast22;
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidCounterOperation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidCounterOperation");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidCounterOperation &a, InvalidCounterOperation &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.__isset, b.__isset);
}

InvalidCounterOperation::InvalidCounterOperation(const InvalidCounterOperation& other23) : TException() {
  code = other23.code;
  __isset = other23.__isset;
}
InvalidCounterOperation& InvalidCounterOperation::operator=(const InvalidCounterOperation& other24) {
  code = other24.code;
  __isset = other24.__isset;
  return *this;
}
void InvalidCounterOperation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidCounterOperation(";
  out << "code=" << to_string(code);
  out << ")";
}

const char* InvalidCounterOperation::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidCounterOperation";
  }
}


InvalidSwapOperation::~InvalidSwapOperation() noexcept {
}


void InvalidSwapOperation::__set_code(const SwapOperationErrorCode::type val) {
  this->code = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidSwapOperation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidSwapOperation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast25;
          xfer += iprot->readI32(ecast25);
          this->code = (SwapOperationErrorCode::type)ecast25;
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidSwapOperation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidSwapOperation");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidSwapOperation &a, InvalidSwapOperation &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.__isset, b.__isset);
}

InvalidSwapOperation::InvalidSwapOperation(const InvalidSwapOperation& other26) : TException() {
  code = other26.code;
  __isset = other26.__isset;
}
InvalidSwapOperation& InvalidSwapOperation::operator=(const InvalidSwapOperation& other27) {
  code = other27.code;
  __isset = other27.__isset;
  return *this;
}
void InvalidSwapOperation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidSwapOperation(";
  out << "code=" << to_string(code);
  out << ")";
}

const char* InvalidSwapOperation::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidSwapOperation";
  }
}


InvalidMeterOperation::~InvalidMeterOperation() noexcept {
}


void InvalidMeterOperation::__set_code(const MeterOperationErrorCode::type val) {
  this->code = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidMeterOperation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidMeterOperation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast28;
          xfer += iprot->readI32(ecast28);
          this->code = (MeterOperationErrorCode::type)ecast28;
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidMeterOperation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidMeterOperation");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidMeterOperation &a, InvalidMeterOperation &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.__isset, b.__isset);
}

InvalidMeterOperation::InvalidMeterOperation(const InvalidMeterOperation& other29) : TException() {
  code = other29.code;
  __isset = other29.__isset;
}
InvalidMeterOperation& InvalidMeterOperation::operator=(const InvalidMeterOperation& other30) {
  code = other30.code;
  __isset = other30.__isset;
  return *this;
}
void InvalidMeterOperation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidMeterOperation(";
  out << "code=" << to_string(code);
  out << ")";
}

const char* InvalidMeterOperation::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidMeterOperation";
  }
}


InvalidRegisterOperation::~InvalidRegisterOperation() noexcept {
}


void InvalidRegisterOperation::__set_code(const RegisterOperationErrorCode::type val) {
  this->code = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidRegisterOperation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidRegisterOperation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast31;
          xfer += iprot->readI32(ecast31);
          this->code = (RegisterOperationErrorCode::type)ecast31;
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidRegisterOperation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidRegisterOperation");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidRegisterOperation &a, InvalidRegisterOperation &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.__isset, b.__isset);
}

InvalidRegisterOperation::InvalidRegisterOperation(const InvalidRegisterOperation& other32) : TException() {
  code = other32.code;
  __isset = other32.__isset;
}
InvalidRegisterOperation& InvalidRegisterOperation::operator=(const InvalidRegisterOperation& other33) {
  code = other33.code;
  __isset = other33.__isset;
  return *this;
}
void InvalidRegisterOperation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidRegisterOperation(";
  out << "code=" << to_string(code);
  out << ")";
}

const char* InvalidRegisterOperation::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidRegisterOperation";
  }
}


InvalidParseVSetOperation::~InvalidParseVSetOperation() noexcept {
}


void InvalidParseVSetOperation::__set_code(const ParseVSetOperationErrorCode::type val) {
  this->code = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidParseVSetOperation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidParseVSetOperation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast34;
          xfer += iprot->readI32(ecast34);
          this->code = (ParseVSetOperationErrorCode::type)ecast34;
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidParseVSetOperation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidParseVSetOperation");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidParseVSetOperation &a, InvalidParseVSetOperation &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.__isset, b.__isset);
}

InvalidParseVSetOperation::InvalidParseVSetOperation(const InvalidParseVSetOperation& other35) : TException() {
  code = other35.code;
  __isset = other35.__isset;
}
InvalidParseVSetOperation& InvalidParseVSetOperation::operator=(const InvalidParseVSetOperation& other36) {
  code = other36.code;
  __isset = other36.__isset;
  return *this;
}
void InvalidParseVSetOperation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidParseVSetOperation(";
  out << "code=" << to_string(code);
  out << ")";
}

const char* InvalidParseVSetOperation::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidParseVSetOperation";
  }
}


InvalidLearnOperation::~InvalidLearnOperation() noexcept {
}


void InvalidLearnOperation::__set_code(const LearnOperationErrorCode::type val) {
  this->code = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidLearnOperation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidLearnOperation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast37;
          xfer += iprot->readI32(ecast37);
          this->code = (LearnOperationErrorCode::type)ecast37;
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidLearnOperation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidLearnOperation");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidLearnOperation &a, InvalidLearnOperation &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.__isset, b.__isset);
}

InvalidLearnOperation::InvalidLearnOperation(const InvalidLearnOperation& other38) : TException() {
  code = other38.code;
  __isset = other38.__isset;
}
InvalidLearnOperation& InvalidLearnOperation::operator=(const InvalidLearnOperation& other39) {
  code = other39.code;
  __isset = other39.__isset;
  return *this;
}
void InvalidLearnOperation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidLearnOperation(";
  out << "code=" << to_string(code);
  out << ")";
}

const char* InvalidLearnOperation::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidLearnOperation";
  }
}


InvalidDevMgrOperation::~InvalidDevMgrOperation() noexcept {
}


void InvalidDevMgrOperation::__set_code(const DevMgrErrorCode::type val) {
  this->code = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidDevMgrOperation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidDevMgrOperation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast40;
          xfer += iprot->readI32(ecast40);
          this->code = (DevMgrErrorCode::type)ecast40;
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidDevMgrOperation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidDevMgrOperation");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidDevMgrOperation &a, InvalidDevMgrOperation &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.__isset, b.__isset);
}

InvalidDevMgrOperation::InvalidDevMgrOperation(const InvalidDevMgrOperation& other41) : TException() {
  code = other41.code;
  __isset = other41.__isset;
}
InvalidDevMgrOperation& InvalidDevMgrOperation::operator=(const InvalidDevMgrOperation& other42) {
  code = other42.code;
  __isset = other42.__isset;
  return *this;
}
void InvalidDevMgrOperation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidDevMgrOperation(";
  out << "code=" << to_string(code);
  out << ")";
}

const char* InvalidDevMgrOperation::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidDevMgrOperation";
  }
}


DevMgrPortInfo::~DevMgrPortInfo() noexcept {
}


void DevMgrPortInfo::__set_port_num(const int32_t val) {
  this->port_num = val;
}

void DevMgrPortInfo::__set_iface_name(const std::string& val) {
  this->iface_name = val;
}

void DevMgrPortInfo::__set_is_up(const bool val) {
  this->is_up = val;
}

void DevMgrPortInfo::__set_extra(const std::map<std::string, std::string> & val) {
  this->extra = val;
}
std::ostream& operator<<(std::ostream& out, const DevMgrPortInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DevMgrPortInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port_num);
          this->__isset.port_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->iface_name);
          this->__isset.iface_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_up);
          this->__isset.is_up = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extra.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _ktype44;
            ::apache::thrift::protocol::TType _vtype45;
            xfer += iprot->readMapBegin(_ktype44, _vtype45, _size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              std::string _key48;
              xfer += iprot->readString(_key48);
              std::string& _val49 = this->extra[_key48];
              xfer += iprot->readString(_val49);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extra = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DevMgrPortInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DevMgrPortInfo");

  xfer += oprot->writeFieldBegin("port_num", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->port_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iface_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->iface_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_up", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_up);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extra", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->extra.size()));
    std::map<std::string, std::string> ::const_iterator _iter50;
    for (_iter50 = this->extra.begin(); _iter50 != this->extra.end(); ++_iter50)
    {
      xfer += oprot->writeString(_iter50->first);
      xfer += oprot->writeString(_iter50->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DevMgrPortInfo &a, DevMgrPortInfo &b) {
  using ::std::swap;
  swap(a.port_num, b.port_num);
  swap(a.iface_name, b.iface_name);
  swap(a.is_up, b.is_up);
  swap(a.extra, b.extra);
  swap(a.__isset, b.__isset);
}

DevMgrPortInfo::DevMgrPortInfo(const DevMgrPortInfo& other51) {
  port_num = other51.port_num;
  iface_name = other51.iface_name;
  is_up = other51.is_up;
  extra = other51.extra;
  __isset = other51.__isset;
}
DevMgrPortInfo& DevMgrPortInfo::operator=(const DevMgrPortInfo& other52) {
  port_num = other52.port_num;
  iface_name = other52.iface_name;
  is_up = other52.is_up;
  extra = other52.extra;
  __isset = other52.__isset;
  return *this;
}
void DevMgrPortInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DevMgrPortInfo(";
  out << "port_num=" << to_string(port_num);
  out << ", " << "iface_name=" << to_string(iface_name);
  out << ", " << "is_up=" << to_string(is_up);
  out << ", " << "extra=" << to_string(extra);
  out << ")";
}


BmCrc16Config::~BmCrc16Config() noexcept {
}


void BmCrc16Config::__set_polynomial(const int16_t val) {
  this->polynomial = val;
}

void BmCrc16Config::__set_initial_remainder(const int16_t val) {
  this->initial_remainder = val;
}

void BmCrc16Config::__set_final_xor_value(const int16_t val) {
  this->final_xor_value = val;
}

void BmCrc16Config::__set_data_reflected(const bool val) {
  this->data_reflected = val;
}

void BmCrc16Config::__set_remainder_reflected(const bool val) {
  this->remainder_reflected = val;
}
std::ostream& operator<<(std::ostream& out, const BmCrc16Config& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BmCrc16Config::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->polynomial);
          this->__isset.polynomial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->initial_remainder);
          this->__isset.initial_remainder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->final_xor_value);
          this->__isset.final_xor_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->data_reflected);
          this->__isset.data_reflected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->remainder_reflected);
          this->__isset.remainder_reflected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BmCrc16Config::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BmCrc16Config");

  xfer += oprot->writeFieldBegin("polynomial", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->polynomial);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("initial_remainder", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->initial_remainder);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("final_xor_value", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->final_xor_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data_reflected", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->data_reflected);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remainder_reflected", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->remainder_reflected);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BmCrc16Config &a, BmCrc16Config &b) {
  using ::std::swap;
  swap(a.polynomial, b.polynomial);
  swap(a.initial_remainder, b.initial_remainder);
  swap(a.final_xor_value, b.final_xor_value);
  swap(a.data_reflected, b.data_reflected);
  swap(a.remainder_reflected, b.remainder_reflected);
  swap(a.__isset, b.__isset);
}

BmCrc16Config::BmCrc16Config(const BmCrc16Config& other53) {
  polynomial = other53.polynomial;
  initial_remainder = other53.initial_remainder;
  final_xor_value = other53.final_xor_value;
  data_reflected = other53.data_reflected;
  remainder_reflected = other53.remainder_reflected;
  __isset = other53.__isset;
}
BmCrc16Config& BmCrc16Config::operator=(const BmCrc16Config& other54) {
  polynomial = other54.polynomial;
  initial_remainder = other54.initial_remainder;
  final_xor_value = other54.final_xor_value;
  data_reflected = other54.data_reflected;
  remainder_reflected = other54.remainder_reflected;
  __isset = other54.__isset;
  return *this;
}
void BmCrc16Config::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BmCrc16Config(";
  out << "polynomial=" << to_string(polynomial);
  out << ", " << "initial_remainder=" << to_string(initial_remainder);
  out << ", " << "final_xor_value=" << to_string(final_xor_value);
  out << ", " << "data_reflected=" << to_string(data_reflected);
  out << ", " << "remainder_reflected=" << to_string(remainder_reflected);
  out << ")";
}


BmCrc32Config::~BmCrc32Config() noexcept {
}


void BmCrc32Config::__set_polynomial(const int32_t val) {
  this->polynomial = val;
}

void BmCrc32Config::__set_initial_remainder(const int32_t val) {
  this->initial_remainder = val;
}

void BmCrc32Config::__set_final_xor_value(const int32_t val) {
  this->final_xor_value = val;
}

void BmCrc32Config::__set_data_reflected(const bool val) {
  this->data_reflected = val;
}

void BmCrc32Config::__set_remainder_reflected(const bool val) {
  this->remainder_reflected = val;
}
std::ostream& operator<<(std::ostream& out, const BmCrc32Config& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BmCrc32Config::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->polynomial);
          this->__isset.polynomial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->initial_remainder);
          this->__isset.initial_remainder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->final_xor_value);
          this->__isset.final_xor_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->data_reflected);
          this->__isset.data_reflected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->remainder_reflected);
          this->__isset.remainder_reflected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BmCrc32Config::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BmCrc32Config");

  xfer += oprot->writeFieldBegin("polynomial", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->polynomial);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("initial_remainder", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->initial_remainder);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("final_xor_value", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->final_xor_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data_reflected", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->data_reflected);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remainder_reflected", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->remainder_reflected);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BmCrc32Config &a, BmCrc32Config &b) {
  using ::std::swap;
  swap(a.polynomial, b.polynomial);
  swap(a.initial_remainder, b.initial_remainder);
  swap(a.final_xor_value, b.final_xor_value);
  swap(a.data_reflected, b.data_reflected);
  swap(a.remainder_reflected, b.remainder_reflected);
  swap(a.__isset, b.__isset);
}

BmCrc32Config::BmCrc32Config(const BmCrc32Config& other55) {
  polynomial = other55.polynomial;
  initial_remainder = other55.initial_remainder;
  final_xor_value = other55.final_xor_value;
  data_reflected = other55.data_reflected;
  remainder_reflected = other55.remainder_reflected;
  __isset = other55.__isset;
}
BmCrc32Config& BmCrc32Config::operator=(const BmCrc32Config& other56) {
  polynomial = other56.polynomial;
  initial_remainder = other56.initial_remainder;
  final_xor_value = other56.final_xor_value;
  data_reflected = other56.data_reflected;
  remainder_reflected = other56.remainder_reflected;
  __isset = other56.__isset;
  return *this;
}
void BmCrc32Config::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BmCrc32Config(";
  out << "polynomial=" << to_string(polynomial);
  out << ", " << "initial_remainder=" << to_string(initial_remainder);
  out << ", " << "final_xor_value=" << to_string(final_xor_value);
  out << ", " << "data_reflected=" << to_string(data_reflected);
  out << ", " << "remainder_reflected=" << to_string(remainder_reflected);
  out << ")";
}


InvalidCrcOperation::~InvalidCrcOperation() noexcept {
}


void InvalidCrcOperation::__set_code(const CrcErrorCode::type val) {
  this->code = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidCrcOperation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidCrcOperation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast57;
          xfer += iprot->readI32(ecast57);
          this->code = (CrcErrorCode::type)ecast57;
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidCrcOperation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidCrcOperation");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidCrcOperation &a, InvalidCrcOperation &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.__isset, b.__isset);
}

InvalidCrcOperation::InvalidCrcOperation(const InvalidCrcOperation& other58) : TException() {
  code = other58.code;
  __isset = other58.__isset;
}
InvalidCrcOperation& InvalidCrcOperation::operator=(const InvalidCrcOperation& other59) {
  code = other59.code;
  __isset = other59.__isset;
  return *this;
}
void InvalidCrcOperation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidCrcOperation(";
  out << "code=" << to_string(code);
  out << ")";
}

const char* InvalidCrcOperation::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidCrcOperation";
  }
}


BmActionEntry::~BmActionEntry() noexcept {
}


void BmActionEntry::__set_action_type(const BmActionEntryType::type val) {
  this->action_type = val;
}

void BmActionEntry::__set_action_name(const std::string& val) {
  this->action_name = val;
__isset.action_name = true;
}

void BmActionEntry::__set_action_data(const BmActionData& val) {
  this->action_data = val;
__isset.action_data = true;
}

void BmActionEntry::__set_mbr_handle(const BmMemberHandle val) {
  this->mbr_handle = val;
__isset.mbr_handle = true;
}

void BmActionEntry::__set_grp_handle(const BmGroupHandle val) {
  this->grp_handle = val;
__isset.grp_handle = true;
}
std::ostream& operator<<(std::ostream& out, const BmActionEntry& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BmActionEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast60;
          xfer += iprot->readI32(ecast60);
          this->action_type = (BmActionEntryType::type)ecast60;
          this->__isset.action_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->action_name);
          this->__isset.action_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->action_data.clear();
            uint32_t _size61;
            ::apache::thrift::protocol::TType _etype64;
            xfer += iprot->readListBegin(_etype64, _size61);
            this->action_data.resize(_size61);
            uint32_t _i65;
            for (_i65 = 0; _i65 < _size61; ++_i65)
            {
              xfer += iprot->readBinary(this->action_data[_i65]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.action_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mbr_handle);
          this->__isset.mbr_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->grp_handle);
          this->__isset.grp_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BmActionEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BmActionEntry");

  xfer += oprot->writeFieldBegin("action_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->action_type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.action_name) {
    xfer += oprot->writeFieldBegin("action_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->action_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.action_data) {
    xfer += oprot->writeFieldBegin("action_data", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->action_data.size()));
      std::vector<std::string> ::const_iterator _iter66;
      for (_iter66 = this->action_data.begin(); _iter66 != this->action_data.end(); ++_iter66)
      {
        xfer += oprot->writeBinary((*_iter66));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mbr_handle) {
    xfer += oprot->writeFieldBegin("mbr_handle", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->mbr_handle);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.grp_handle) {
    xfer += oprot->writeFieldBegin("grp_handle", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->grp_handle);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BmActionEntry &a, BmActionEntry &b) {
  using ::std::swap;
  swap(a.action_type, b.action_type);
  swap(a.action_name, b.action_name);
  swap(a.action_data, b.action_data);
  swap(a.mbr_handle, b.mbr_handle);
  swap(a.grp_handle, b.grp_handle);
  swap(a.__isset, b.__isset);
}

BmActionEntry::BmActionEntry(const BmActionEntry& other67) {
  action_type = other67.action_type;
  action_name = other67.action_name;
  action_data = other67.action_data;
  mbr_handle = other67.mbr_handle;
  grp_handle = other67.grp_handle;
  __isset = other67.__isset;
}
BmActionEntry& BmActionEntry::operator=(const BmActionEntry& other68) {
  action_type = other68.action_type;
  action_name = other68.action_name;
  action_data = other68.action_data;
  mbr_handle = other68.mbr_handle;
  grp_handle = other68.grp_handle;
  __isset = other68.__isset;
  return *this;
}
void BmActionEntry::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BmActionEntry(";
  out << "action_type=" << to_string(action_type);
  out << ", " << "action_name="; (__isset.action_name ? (out << to_string(action_name)) : (out << "<null>"));
  out << ", " << "action_data="; (__isset.action_data ? (out << to_string(action_data)) : (out << "<null>"));
  out << ", " << "mbr_handle="; (__isset.mbr_handle ? (out << to_string(mbr_handle)) : (out << "<null>"));
  out << ", " << "grp_handle="; (__isset.grp_handle ? (out << to_string(grp_handle)) : (out << "<null>"));
  out << ")";
}


BmMtEntryLife::~BmMtEntryLife() noexcept {
}


void BmMtEntryLife::__set_timeout_ms(const int32_t val) {
  this->timeout_ms = val;
}

void BmMtEntryLife::__set_time_since_hit_ms(const int32_t val) {
  this->time_since_hit_ms = val;
}
std::ostream& operator<<(std::ostream& out, const BmMtEntryLife& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BmMtEntryLife::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeout_ms);
          this->__isset.timeout_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->time_since_hit_ms);
          this->__isset.time_since_hit_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BmMtEntryLife::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BmMtEntryLife");

  xfer += oprot->writeFieldBegin("timeout_ms", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->timeout_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_since_hit_ms", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->time_since_hit_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BmMtEntryLife &a, BmMtEntryLife &b) {
  using ::std::swap;
  swap(a.timeout_ms, b.timeout_ms);
  swap(a.time_since_hit_ms, b.time_since_hit_ms);
  swap(a.__isset, b.__isset);
}

BmMtEntryLife::BmMtEntryLife(const BmMtEntryLife& other69) {
  timeout_ms = other69.timeout_ms;
  time_since_hit_ms = other69.time_since_hit_ms;
  __isset = other69.__isset;
}
BmMtEntryLife& BmMtEntryLife::operator=(const BmMtEntryLife& other70) {
  timeout_ms = other70.timeout_ms;
  time_since_hit_ms = other70.time_since_hit_ms;
  __isset = other70.__isset;
  return *this;
}
void BmMtEntryLife::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BmMtEntryLife(";
  out << "timeout_ms=" << to_string(timeout_ms);
  out << ", " << "time_since_hit_ms=" << to_string(time_since_hit_ms);
  out << ")";
}


BmMtEntry::~BmMtEntry() noexcept {
}


void BmMtEntry::__set_match_key(const BmMatchParams& val) {
  this->match_key = val;
}

void BmMtEntry::__set_options(const BmAddEntryOptions& val) {
  this->options = val;
}

void BmMtEntry::__set_entry_handle(const BmEntryHandle val) {
  this->entry_handle = val;
}

void BmMtEntry::__set_action_entry(const BmActionEntry& val) {
  this->action_entry = val;
}

void BmMtEntry::__set_life(const BmMtEntryLife& val) {
  this->life = val;
__isset.life = true;
}
std::ostream& operator<<(std::ostream& out, const BmMtEntry& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BmMtEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->match_key.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _etype74;
            xfer += iprot->readListBegin(_etype74, _size71);
            this->match_key.resize(_size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              xfer += this->match_key[_i75].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.match_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->entry_handle);
          this->__isset.entry_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->action_entry.read(iprot);
          this->__isset.action_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->life.read(iprot);
          this->__isset.life = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BmMtEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BmMtEntry");

  xfer += oprot->writeFieldBegin("match_key", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->match_key.size()));
    std::vector<BmMatchParam> ::const_iterator _iter76;
    for (_iter76 = this->match_key.begin(); _iter76 != this->match_key.end(); ++_iter76)
    {
      xfer += (*_iter76).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->options.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entry_handle", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->entry_handle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("action_entry", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->action_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.life) {
    xfer += oprot->writeFieldBegin("life", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->life.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BmMtEntry &a, BmMtEntry &b) {
  using ::std::swap;
  swap(a.match_key, b.match_key);
  swap(a.options, b.options);
  swap(a.entry_handle, b.entry_handle);
  swap(a.action_entry, b.action_entry);
  swap(a.life, b.life);
  swap(a.__isset, b.__isset);
}

BmMtEntry::BmMtEntry(const BmMtEntry& other77) {
  match_key = other77.match_key;
  options = other77.options;
  entry_handle = other77.entry_handle;
  action_entry = other77.action_entry;
  life = other77.life;
  __isset = other77.__isset;
}
BmMtEntry& BmMtEntry::operator=(const BmMtEntry& other78) {
  match_key = other78.match_key;
  options = other78.options;
  entry_handle = other78.entry_handle;
  action_entry = other78.action_entry;
  life = other78.life;
  __isset = other78.__isset;
  return *this;
}
void BmMtEntry::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BmMtEntry(";
  out << "match_key=" << to_string(match_key);
  out << ", " << "options=" << to_string(options);
  out << ", " << "entry_handle=" << to_string(entry_handle);
  out << ", " << "action_entry=" << to_string(action_entry);
  out << ", " << "life="; (__isset.life ? (out << to_string(life)) : (out << "<null>"));
  out << ")";
}


BmMtActProfMember::~BmMtActProfMember() noexcept {
}


void BmMtActProfMember::__set_mbr_handle(const BmMemberHandle val) {
  this->mbr_handle = val;
}

void BmMtActProfMember::__set_action_name(const std::string& val) {
  this->action_name = val;
}

void BmMtActProfMember::__set_action_data(const BmActionData& val) {
  this->action_data = val;
}
std::ostream& operator<<(std::ostream& out, const BmMtActProfMember& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BmMtActProfMember::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mbr_handle);
          this->__isset.mbr_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->action_name);
          this->__isset.action_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->action_data.clear();
            uint32_t _size79;
            ::apache::thrift::protocol::TType _etype82;
            xfer += iprot->readListBegin(_etype82, _size79);
            this->action_data.resize(_size79);
            uint32_t _i83;
            for (_i83 = 0; _i83 < _size79; ++_i83)
            {
              xfer += iprot->readBinary(this->action_data[_i83]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.action_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BmMtActProfMember::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BmMtActProfMember");

  xfer += oprot->writeFieldBegin("mbr_handle", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->mbr_handle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("action_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->action_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("action_data", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->action_data.size()));
    std::vector<std::string> ::const_iterator _iter84;
    for (_iter84 = this->action_data.begin(); _iter84 != this->action_data.end(); ++_iter84)
    {
      xfer += oprot->writeBinary((*_iter84));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BmMtActProfMember &a, BmMtActProfMember &b) {
  using ::std::swap;
  swap(a.mbr_handle, b.mbr_handle);
  swap(a.action_name, b.action_name);
  swap(a.action_data, b.action_data);
  swap(a.__isset, b.__isset);
}

BmMtActProfMember::BmMtActProfMember(const BmMtActProfMember& other85) {
  mbr_handle = other85.mbr_handle;
  action_name = other85.action_name;
  action_data = other85.action_data;
  __isset = other85.__isset;
}
BmMtActProfMember& BmMtActProfMember::operator=(const BmMtActProfMember& other86) {
  mbr_handle = other86.mbr_handle;
  action_name = other86.action_name;
  action_data = other86.action_data;
  __isset = other86.__isset;
  return *this;
}
void BmMtActProfMember::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BmMtActProfMember(";
  out << "mbr_handle=" << to_string(mbr_handle);
  out << ", " << "action_name=" << to_string(action_name);
  out << ", " << "action_data=" << to_string(action_data);
  out << ")";
}


BmMtActProfGroup::~BmMtActProfGroup() noexcept {
}


void BmMtActProfGroup::__set_grp_handle(const BmGroupHandle val) {
  this->grp_handle = val;
}

void BmMtActProfGroup::__set_mbr_handles(const std::vector<BmMemberHandle> & val) {
  this->mbr_handles = val;
}
std::ostream& operator<<(std::ostream& out, const BmMtActProfGroup& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BmMtActProfGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->grp_handle);
          this->__isset.grp_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mbr_handles.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _etype90;
            xfer += iprot->readListBegin(_etype90, _size87);
            this->mbr_handles.resize(_size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              xfer += iprot->readI32(this->mbr_handles[_i91]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.mbr_handles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BmMtActProfGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BmMtActProfGroup");

  xfer += oprot->writeFieldBegin("grp_handle", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->grp_handle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mbr_handles", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->mbr_handles.size()));
    std::vector<BmMemberHandle> ::const_iterator _iter92;
    for (_iter92 = this->mbr_handles.begin(); _iter92 != this->mbr_handles.end(); ++_iter92)
    {
      xfer += oprot->writeI32((*_iter92));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BmMtActProfGroup &a, BmMtActProfGroup &b) {
  using ::std::swap;
  swap(a.grp_handle, b.grp_handle);
  swap(a.mbr_handles, b.mbr_handles);
  swap(a.__isset, b.__isset);
}

BmMtActProfGroup::BmMtActProfGroup(const BmMtActProfGroup& other93) {
  grp_handle = other93.grp_handle;
  mbr_handles = other93.mbr_handles;
  __isset = other93.__isset;
}
BmMtActProfGroup& BmMtActProfGroup::operator=(const BmMtActProfGroup& other94) {
  grp_handle = other94.grp_handle;
  mbr_handles = other94.mbr_handles;
  __isset = other94.__isset;
  return *this;
}
void BmMtActProfGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BmMtActProfGroup(";
  out << "grp_handle=" << to_string(grp_handle);
  out << ", " << "mbr_handles=" << to_string(mbr_handles);
  out << ")";
}


BmConfig::~BmConfig() noexcept {
}


void BmConfig::__set_device_id(const int64_t val) {
  this->device_id = val;
}

void BmConfig::__set_thrift_port(const int32_t val) {
  this->thrift_port = val;
}

void BmConfig::__set_notifications_socket(const std::string& val) {
  this->notifications_socket = val;
__isset.notifications_socket = true;
}

void BmConfig::__set_elogger_socket(const std::string& val) {
  this->elogger_socket = val;
__isset.elogger_socket = true;
}

void BmConfig::__set_debugger_socket(const std::string& val) {
  this->debugger_socket = val;
__isset.debugger_socket = true;
}
std::ostream& operator<<(std::ostream& out, const BmConfig& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BmConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->device_id);
          this->__isset.device_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->thrift_port);
          this->__isset.thrift_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->notifications_socket);
          this->__isset.notifications_socket = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->elogger_socket);
          this->__isset.elogger_socket = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->debugger_socket);
          this->__isset.debugger_socket = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BmConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BmConfig");

  xfer += oprot->writeFieldBegin("device_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->device_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->thrift_port);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.notifications_socket) {
    xfer += oprot->writeFieldBegin("notifications_socket", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->notifications_socket);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.elogger_socket) {
    xfer += oprot->writeFieldBegin("elogger_socket", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->elogger_socket);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.debugger_socket) {
    xfer += oprot->writeFieldBegin("debugger_socket", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->debugger_socket);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BmConfig &a, BmConfig &b) {
  using ::std::swap;
  swap(a.device_id, b.device_id);
  swap(a.thrift_port, b.thrift_port);
  swap(a.notifications_socket, b.notifications_socket);
  swap(a.elogger_socket, b.elogger_socket);
  swap(a.debugger_socket, b.debugger_socket);
  swap(a.__isset, b.__isset);
}

BmConfig::BmConfig(const BmConfig& other95) {
  device_id = other95.device_id;
  thrift_port = other95.thrift_port;
  notifications_socket = other95.notifications_socket;
  elogger_socket = other95.elogger_socket;
  debugger_socket = other95.debugger_socket;
  __isset = other95.__isset;
}
BmConfig& BmConfig::operator=(const BmConfig& other96) {
  device_id = other96.device_id;
  thrift_port = other96.thrift_port;
  notifications_socket = other96.notifications_socket;
  elogger_socket = other96.elogger_socket;
  debugger_socket = other96.debugger_socket;
  __isset = other96.__isset;
  return *this;
}
void BmConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BmConfig(";
  out << "device_id=" << to_string(device_id);
  out << ", " << "thrift_port=" << to_string(thrift_port);
  out << ", " << "notifications_socket="; (__isset.notifications_socket ? (out << to_string(notifications_socket)) : (out << "<null>"));
  out << ", " << "elogger_socket="; (__isset.elogger_socket ? (out << to_string(elogger_socket)) : (out << "<null>"));
  out << ", " << "debugger_socket="; (__isset.debugger_socket ? (out << to_string(debugger_socket)) : (out << "<null>"));
  out << ")";
}


InvalidIdLookup::~InvalidIdLookup() noexcept {
}


void InvalidIdLookup::__set_code(const IdLookupErrorCode::type val) {
  this->code = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidIdLookup& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidIdLookup::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast97;
          xfer += iprot->readI32(ecast97);
          this->code = (IdLookupErrorCode::type)ecast97;
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidIdLookup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidIdLookup");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidIdLookup &a, InvalidIdLookup &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.__isset, b.__isset);
}

InvalidIdLookup::InvalidIdLookup(const InvalidIdLookup& other98) : TException() {
  code = other98.code;
  __isset = other98.__isset;
}
InvalidIdLookup& InvalidIdLookup::operator=(const InvalidIdLookup& other99) {
  code = other99.code;
  __isset = other99.__isset;
  return *this;
}
void InvalidIdLookup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidIdLookup(";
  out << "code=" << to_string(code);
  out << ")";
}

const char* InvalidIdLookup::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidIdLookup";
  }
}

}} // namespace
